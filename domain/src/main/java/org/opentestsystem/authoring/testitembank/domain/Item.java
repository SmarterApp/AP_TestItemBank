/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testitembank.domain;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.CompoundIndexes;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

@JsonIgnoreProperties(ignoreUnknown = true)
@CompoundIndexes(value = { @CompoundIndex(name = "item_identifier_indx", def = "{'tenantId':1, 'identifier':1}", unique = true) })
public class Item extends AbstractItem {

    private static final String GET_RESOURCE_NAME = "item/";

    private static final String HISTORY_RESOURCE_NAME = "/history";

    @Id
    private String id;

    private String identifier;

    public Item() {
        // jackson
    }

    public String getId() {
        return this.id;
    }

    public void setId(final String id) {
        this.id = id;
    }

    @Override
    public String getIdentifier() {
        return this.identifier;
    }

    @Override
    public void setIdentifier(final String inIdentifier) {
        this.identifier = inIdentifier;
    }

    @Override
    @JsonProperty
    public String getUrl() {
        return GET_RESOURCE_NAME + getIdentifier();
    }

    @JsonProperty
    public String getItemHistoryURI() {
        return GET_RESOURCE_NAME + getIdentifier() + HISTORY_RESOURCE_NAME;
    }

    public int compareByVersion(final Item existingItem) {
        int ret = -1;
        if (isEmpty(getVersion())) {
            ret = -1;
        } else if (existingItem == null || isEmpty(existingItem.getVersion())) {
            ret = 1;
        } else {
            ret = compareVersions(existingItem.getVersion());
        }
        return ret;
    }

    private int compareVersions(final String inVersion) {
        // the versions strings are assumed valid (positive numeric values)
        final String[] myVersionSplit = getVersion().split("\\.");
        final String[] otherVersionSplit = inVersion.split("\\.");
        final String mineToParse = myVersionSplit.length > 1 ? myVersionSplit[0] : getVersion();
        // assumes valid version (positive numeric)
        int myVersionPrefix = 0;
        try {
            myVersionPrefix = Integer.parseInt(mineToParse);
        } catch (final NumberFormatException e) {
            // if wer're invalid, other number wins on default.
            return -1;
        }
        final String otherToParse = otherVersionSplit.length > 1 ? otherVersionSplit[0] : inVersion;
        // assumes valid version (positive numeric)
        int otherVersionPrefix = 0;
        try {
            otherVersionPrefix = Integer.parseInt(otherToParse);
        } catch (final NumberFormatException e) {
            // if other version is invalid we're greater
            return 1;
        }
        int ret = 0;
        if (myVersionPrefix > otherVersionPrefix) {
            ret = 1;
        } else if (myVersionPrefix < otherVersionPrefix) {
            ret = -1;
        } else {
            ret = compareVersionSuffix(myVersionSplit, otherVersionSplit);
        }

        return ret;
    }

    private int compareVersionSuffix(final String[] myVersionSplit, final String[] otherVersionSplit) {
        int ret = 0;
        // I only have prefix
        if (myVersionSplit.length < 2) {
            // if the other has a suffix, it's greater.
            if (otherVersionSplit.length > 1) {
                ret = -1;
            }
            // no else, it's a tie default 0
        } else {
            if (otherVersionSplit.length > 1) {
                int mySuffix;
                try {
                    mySuffix = Integer.parseInt(myVersionSplit[1]);
                } catch (final NumberFormatException e) {
                    // if our version is invalid other wins by default
                    return -1;
                }
                int otherSuffix;
                try {
                    otherSuffix = Integer.parseInt(otherVersionSplit[1]);
                } catch (final NumberFormatException e) {
                    // if other version is invalid we win by default
                    return 1;
                }
                // both have a suffix, tie breaker goes to greater one.
                ret = mySuffix > otherSuffix ? 1 : mySuffix == otherSuffix ? 0 : -1;
            } else {
                // if other doesn't have a suffix we're greater
                ret = 1;
            }
        }
        return ret;
    }

    private boolean isEmpty(final String toCheck) {
        return toCheck == null || toCheck.trim().length() < 1;
    }

}
