/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testitembank.service.impl;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBException;

import org.apache.commons.io.IOUtils;
import org.joda.time.DateTime;
import org.opentestsystem.authoring.testitembank.domain.ExportItem;
import org.opentestsystem.authoring.testitembank.domain.ExportSet;
import org.opentestsystem.authoring.testitembank.domain.ExportStatus;
import org.opentestsystem.authoring.testitembank.domain.ItemHistory;
import org.opentestsystem.authoring.testitembank.persistence.ExportSetRepository;
import org.opentestsystem.authoring.testitembank.persistence.GridFsRepository;
import org.opentestsystem.authoring.testitembank.persistence.ItemHistoryRepository;
import org.opentestsystem.authoring.testitembank.service.ExportSetService;
import org.opentestsystem.authoring.testitembank.service.FileTransferService;
import org.opentestsystem.authoring.testitembank.service.ZipOutputFileBuilderService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.file.remote.session.Session;
import org.springframework.scheduling.annotation.Async;
import org.springframework.util.CollectionUtils;

public class ExportSetServiceImpl implements ExportSetService {
    /** logger. */
    private static final Logger LOGGER = LoggerFactory.getLogger(ExportSetServiceImpl.class);

    private static final String SFTP_TENANT_FOLDER_PREFIX = "tenant_";
    private static final String EXPORT_SET_FILENAME_PREFIX = "exportSet_";

    @Autowired
    private ExportSetRepository exportSetRepository;

    @Autowired
    private ItemHistoryRepository itemHistoryRepository;

    @Autowired
    private ZipOutputFileBuilderService zipOutputFileBuilderService;

    @Autowired
    private GridFsRepository gridFsRepository;

    @Autowired
    private FileTransferService sftpFileTransferService;

    @Override
    public ExportSet saveExportSet(final ExportSet exportSet) {
        final ExportSet saved = exportSetRepository.save(exportSet);
        return saved;
    }

    @Override
    public ExportSet getExportSet(final String exportSetId) {
        return exportSetRepository.findOne(exportSetId);
    }

    @Async
    @Override
    public void exportFileSet(final ExportSet exportSet) {
        final String targetParentDir = SFTP_TENANT_FOLDER_PREFIX + exportSet.getTenantId() + "/";
        final String targetFilePath = targetParentDir + EXPORT_SET_FILENAME_PREFIX + exportSet.getId() + ".zip";

        if (!CollectionUtils.isEmpty(exportSet.getItems())) {

            // retrieve items from mongo
            final List<ItemHistory> itemHistories = new ArrayList<ItemHistory>();
            final List<ExportItem> invalidItems = new ArrayList<ExportItem>();
            for (final ExportItem item : exportSet.getItems()) {
                final ItemHistory historyItem = itemHistoryRepository.findByTenantIdAndIdentifierAndVersion(exportSet.getTenantId(), item.getIdentifier(), item.getVersion());
                if (historyItem == null) {
                    LOGGER.info("Export Failed: Item " + item.getIdentifier() + " (v" + item.getVersion() + ") not found for tenant: " + exportSet.getTenantId());
                    invalidItems.add(item);
                } else {
                    itemHistories.add(historyItem);
                }
            }

            // validate missing items
            if (!invalidItems.isEmpty()) {
                exportSet.setStatus(ExportStatus.FAILED);
            } else {
                Session<?> sftpSession = null;
                InputStream inputStream = null;
                try {
                    // build zip file
                    final File exportFile = zipOutputFileBuilderService.createExportFile(exportSet.getId(), itemHistories);

                    // get sftp session and create parent directory for the export
                    sftpSession = sftpFileTransferService.getSession();
                    if (!sftpSession.exists(targetParentDir)) {
                        sftpSession.mkdir(targetParentDir);
                    }

                    // write file to SFTP site
                    inputStream = new FileInputStream(exportFile);
                    sftpSession.write(inputStream, targetFilePath);
                } catch (final IOException | JAXBException e) {
                    LOGGER.error("unable to export items for set: " + exportSet.getId() + ":", e);
                    exportSet.setStatus(ExportStatus.FAILED);
                } catch (final Exception e) {
                    exportSet.setStatus(ExportStatus.FAILED);
                    exportSet.setExportCompleted(new DateTime());
                    saveExportSet(exportSet);
                    throw e;
                } finally {
                    IOUtils.closeQuietly(inputStream);
                    if (sftpSession != null && sftpSession.isOpen()) {
                        sftpSession.close();
                    }
                }
            }
        }

        if (!ExportStatus.FAILED.equals(exportSet.getStatus())) {
            exportSet.setStatus(ExportStatus.EXPORT_COMPLETE);
            exportSet.setZipFileName(targetFilePath);
        }
        exportSet.setExportCompleted(new DateTime());
        saveExportSet(exportSet);
    }

    @Override
    public void setSftpFileTransferService(final FileTransferService inSftpFileTransferService) {
        this.sftpFileTransferService = inSftpFileTransferService;
    }

    @Override
    public void setZipOutputFileBuilderService(final ZipOutputFileBuilderService zipOutputFileBuilderService) {
        this.zipOutputFileBuilderService = zipOutputFileBuilderService;
    }

}
