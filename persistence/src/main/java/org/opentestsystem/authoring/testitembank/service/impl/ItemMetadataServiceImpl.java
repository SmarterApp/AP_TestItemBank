/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testitembank.service.impl;

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeSet;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testitembank.domain.ItemMetadata;
import org.opentestsystem.authoring.testitembank.domain.ItemMetadataValue;
import org.opentestsystem.authoring.testitembank.domain.ItemMetadataValueSearchRequest;
import org.opentestsystem.authoring.testitembank.persistence.ItemMetadataRepository;
import org.opentestsystem.authoring.testitembank.persistence.ItemMetadataValueRepository;
import org.opentestsystem.authoring.testitembank.service.ItemMetadataService;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;

public class ItemMetadataServiceImpl implements ItemMetadataService {

    @Autowired
    private ItemMetadataRepository itemMetadataRepository;

    @Autowired
    private ItemMetadataValueRepository itemMetadataValueRepository;

    @SuppressWarnings("unchecked")
    @Override
    public void saveNewItemMetadata(final String tenantId, final String metadataKey, final Object metadataValue) {
        if (isNotBlank(tenantId) && isNotBlank(metadataKey) && isNotBlank(metadataValue.toString())) {
            if (metadataValue instanceof Map) {
                final Map<Object, Object> valueMap = (Map<Object, Object>) metadataValue;
                for (final Entry<Object, Object> entry : valueMap.entrySet()) {
                    if (isNotBlank(entry.getKey()) && isNotBlank(entry.getValue())) {
                        this.saveNewItemMetadata(tenantId, metadataKey + "." + entry.getKey().toString(), entry.getValue());
                    }
                }
            } else if (metadataValue instanceof List) {
                final List<Object> valueList = (List<Object>) metadataValue;
                for (final Object element : valueList) {
                    if (isNotBlank(element)) {
                        this.saveNewItemMetadata(tenantId, metadataKey, element);
                    }
                }
            } else {
                this.saveSimpleItemMetadata(tenantId, metadataKey, metadataValue.toString());
            }
        }
    }

    private void saveSimpleItemMetadata(final String tenantId, final String metadataKey, final String metadataValue) {
        // add new itemMetadata
        ItemMetadata existingMetadata = itemMetadataRepository.findByTenantId(tenantId);
        if (existingMetadata == null) {
            existingMetadata = new ItemMetadata();
            existingMetadata.setTenantId(tenantId);
            existingMetadata.setMetadataKeys(new TreeSet<String>());
        }

        existingMetadata.getMetadataKeys().add(metadataKey);
        itemMetadataRepository.save(existingMetadata);

        // add new itemMetadataValue
        final ItemMetadataValue existingMetadataValue = itemMetadataValueRepository.findByTenantIdAndMetadataKeyAndMetadataValue(tenantId, metadataKey, metadataValue);
        if (existingMetadataValue == null) {
            final ItemMetadataValue newMetadataValue = new ItemMetadataValue();
            newMetadataValue.setTenantId(tenantId);
            newMetadataValue.setMetadataKey(metadataKey);
            newMetadataValue.setMetadataValue(metadataValue);
            itemMetadataValueRepository.save(newMetadataValue);
        }
    }

    @Override
    public ItemMetadata getItemMetadataByTenantId(final String tenantId) {
        return this.itemMetadataRepository.findByTenantId(tenantId);
    }

    @Override
    public SearchResponse<ItemMetadataValue> searchItemMetadataValues(final Map<String, String[]> parameterMap) {
        final ItemMetadataValueSearchRequest searchRequest = new ItemMetadataValueSearchRequest(parameterMap);
        if (searchRequest.isValid()) {
            return this.itemMetadataValueRepository.search(searchRequest);
        } else {
            throw new RestException("itemMetadataValue.search.invalidSearchCriteria");
        }
    }

    private static final boolean isNotBlank(final Object val) {
        return val != null && StringUtils.isNotBlank(val.toString());
    }
}
