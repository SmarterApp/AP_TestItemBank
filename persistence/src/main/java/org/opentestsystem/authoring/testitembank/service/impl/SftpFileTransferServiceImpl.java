/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testitembank.service.impl;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Date;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.authoring.testitembank.exception.TestItemBankException;
import org.opentestsystem.authoring.testitembank.service.FileTransferService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.integration.file.remote.session.Session;
import org.springframework.integration.sftp.session.DefaultSftpSessionFactory;

import com.google.common.collect.ImmutableList;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.ChannelSftp.LsEntry;

public class SftpFileTransferServiceImpl implements FileTransferService {

    /** logger. */
    private static final Logger LOGGER = LoggerFactory.getLogger(SftpFileTransferServiceImpl.class);

    private static final long MILLIS_IN_A_DAY = 24 * 60 * 60 * 1000;
    private static final List<String> REMOTE_DIRS_TO_IGNORE = ImmutableList.of(".", "..");

    @Autowired
    private DefaultSftpSessionFactory sftpSessionFactory;

    // the colon is important to default to blank here. http://www.javacodegeeks.com/2013/01/spring-property-placeholder-configurer-a-few-not-so-obvious-options.html
    @Value(value = "${tib.file.pathname:}${tib.file.importfolder:/tib-imports}")
    private String tempFileDirectory;

    @Override
    public final File getFile(final String importSetId, final String fileName) {
        File file = null;
        FileOutputStream fileOutputStream = null;
        Session<ChannelSftp.LsEntry> sftpSession = null;
        String path = this.tempFileDirectory;
        if (StringUtils.isEmpty(path)) {
            String userDir = System.getProperty("user.dir");
            LOGGER.info("The property 'tib.file.pathname' is not populated, defaulting to :" + userDir);
            path = userDir;
        }

        try {
            sftpSession = this.sftpSessionFactory.getSession();
            final String[] pathPortions = fileName.split("/");
            final String justFileName = pathPortions[pathPortions.length - 1];
            LOGGER.debug("TIB temp dir is: " + path + " file name: " + justFileName);

            path = path + "/importSet_" + importSetId;
            new File(path).mkdirs();

            file = new File(path, justFileName);
            fileOutputStream = new FileOutputStream(file);
            sftpSession.read(fileName, fileOutputStream);

        } catch (final Exception e) {
            LOGGER.error("unable to get file " + fileName + " from sftp site:" + e.getMessage(), e);
            throw new TestItemBankException("sftp.read.error", new String[] { fileName });
        } finally {
            try {
                if (fileOutputStream != null) {
                    fileOutputStream.close();
                }
                if (sftpSession != null) {
                    sftpSession.close();
                }
            } catch (final IOException e) {
                LOGGER.error("unable to get file " + fileName + " from sftp site:" + e.getMessage(), e);
                throw new TestItemBankException("sftp.read.error", new String[] { fileName });
            }
        }
        return file;
    }

    @Override
    public final void writeFile(final String destinationName, final InputStream inputStream) {
        Session<ChannelSftp.LsEntry> sftpSession = null;
        try {
            sftpSession = this.sftpSessionFactory.getSession();
            sftpSession.write(inputStream, destinationName);
        } catch (final Exception e) {
            LOGGER.error("unable to write file to sftp site " + destinationName + " from sftp site:" + e.getMessage());
            throw new TestItemBankException("sftp.write.error", new String[] { destinationName });
        } finally {
            try {
                if (inputStream != null) {
                    inputStream.close();
                }
                if (sftpSession != null) {
                    sftpSession.close();
                }
            } catch (final IOException e) {
                LOGGER.error("unable to write file " + destinationName + " to sftp site:" + e.getMessage());
                throw new TestItemBankException("sftp.write.error", new String[] { destinationName });
            }
        }
    }

    @Override
    public final int cleanDirectory(final String baseDirectory, final int maxAge) {
        int remainingFileCount = 0;

        Session<ChannelSftp.LsEntry> sftpSession = null;
        try {
            sftpSession = this.sftpSessionFactory.getSession();
            remainingFileCount = cleanDirectory(baseDirectory, maxAge, sftpSession);
        } finally {
            if (sftpSession != null) {
                sftpSession.close();
            }
        }

        return remainingFileCount;
    }

    private final int cleanDirectory(final String baseDirectory, final int maxAge, final Session<ChannelSftp.LsEntry> sftpSession) {
        final long maxAgeInMillis = Long.valueOf(maxAge) * MILLIS_IN_A_DAY;
        final long currentTimeInMillis = new Date().getTime();

        int remainingFileCount = 0;
        try {
            final LsEntry[] remoteFiles = sftpSession.list(baseDirectory);
            for (final LsEntry remoteFile : remoteFiles) {
                if (isSubDirectory(remoteFile)) {
                    final int directoryFileCount = cleanDirectory(baseDirectory + "/" + remoteFile.getFilename(), maxAge, sftpSession);
                    remainingFileCount += directoryFileCount;

                    // if (!remoteFile.getFilename().startsWith(ImportSetServiceImpl.SFTP_TENANT_FOLDER_PREFIX) && (directoryFileCount == 0)) {
                    // TODO - do we need to delete empty sub-directories?
                    // TODO - we'll need a different SFTP library for that, or wait for Spring integration 4.1.0 which has rmdir() method
                    // }
                } else if (!isDirectory(remoteFile)) {
                    final long lastModifiedTimeInMillis = Long.valueOf(remoteFile.getAttrs().getMTime()) * 1000L;
                    final long fileAgeInMillis = currentTimeInMillis - lastModifiedTimeInMillis;
                    if (fileAgeInMillis > maxAgeInMillis) {
                        sftpSession.remove(baseDirectory + "/" + remoteFile.getFilename());
                    } else {
                        remainingFileCount++;
                    }
                }
            }
        } catch (final IOException e) {
            LOGGER.error("unable to clean SFTP directory: " + baseDirectory, e);
            throw new TestItemBankException("sftp.clean.error", new String[] { baseDirectory });
        }

        return remainingFileCount;
    }

    private static final boolean isSubDirectory(final LsEntry remoteDir) {
        return isDirectory(remoteDir) && !REMOTE_DIRS_TO_IGNORE.contains(remoteDir.getFilename());
    }

    private static final boolean isDirectory(final LsEntry remoteDir) {
        return remoteDir.getAttrs().isDir();
    }

    @Override
    public final Session<LsEntry> getSession() {
        return this.sftpSessionFactory.getSession();
    }

}
