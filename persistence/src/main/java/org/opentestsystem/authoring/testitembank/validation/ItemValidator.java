/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.authoring.testitembank.validation;

import java.util.List;
import java.util.Map;

import org.opentestsystem.authoring.testitembank.domain.Item;
import org.springframework.validation.BindException;
import org.springframework.validation.Errors;
import org.springframework.validation.ObjectError;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

public class ItemValidator implements Validator {

    @Override
    public final boolean supports(final Class<?> clazz) {
        return Item.class.equals(clazz);
    }

    // subject, language, status

    private static final String[] REQUIRED_SINGLE_METADATA_FIELDS = new String[] { "InteractionType", "Version", "Subject", "SecurityStatus", "MinimumGrade", "IntendedGrade", "MaximumGrade"
            , "ItemSpecFormat", "StimulusFormat"};

    /***
     * , "MaximumNumberOfPoints"
     * , "ScorePoints"
     * , "DepthOfKnowledge"
     * , "Status" 
     * 
     */
    private static final String[] REQUIRED_MUTLIPLE_VALUES = new String[] {  };

    /***
     *  "Language" 
     * 
     */

    
    private static boolean isOneNonEmptyString(final Object obj) {
        boolean value = false;
        Object verify = null;
        if (obj instanceof List) {
            final List<?> lst = (List<?>) obj;
            if (lst.size() == 1) {
                verify = lst.get(0);
            }
        } else {
            verify = obj;
        }
        if (verify != null) {
            final String strValue = verify.toString();
            if (strValue != null && !strValue.isEmpty()) {
                value = true;
            }
        }
        return value;
    }

    private static boolean allNotEmpty(final Object... objs) {
        boolean value = false;
        if (objs != null) {
            if (objs.length > 0) {
                value = true;
            }
            for (final Object obj : objs) {
                if (obj == null || obj.toString().isEmpty()) {
                    value = false;
                }
            }
        }

        return value;
    }

    @Override
    public final void validate(final Object target, final Errors errors) {
        final Item item = (Item) target;
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "identifier", "item.emptyField", new String[] { "identifier", item.getIdentifier(), item.getVersion() });
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "interactionType", "item.emptyField", new String[] { "interactionType", item.getIdentifier(), item.getVersion() });
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "version", "item.emptyField", new String[] { "version", item.getIdentifier(), item.getVersion() });
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "tenantId", "item.emptyField", new String[] { "tenantId", item.getIdentifier(), item.getVersion() });
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "subject", "item.emptyField", new String[] { "subject", item.getIdentifier(), item.getVersion() });

        final Map<String, Object> metadata = item.getAllIncludedMetatdata();
        if (metadata == null || metadata.size() == 0) {
            errors.reject("item.no.metadata", new String[] { item.getIdentifier(), item.getVersion() }, "no metadata found");
        } else {
            for (final String requiredKey : REQUIRED_SINGLE_METADATA_FIELDS) {
                if (!isOneNonEmptyString(metadata.get(requiredKey))) {
                    errors.reject("item.requiredMetadata.missing", new String[] { requiredKey, item.getIdentifier(), item.getVersion() }, "missing required metadata");
                }
            }
            for (final String requiredKey : REQUIRED_MUTLIPLE_VALUES) {
                if (!allNotEmpty(metadata.get(requiredKey))) {
                    errors.reject("item.requiredMetadata.missing", new String[] { requiredKey, item.getIdentifier(), item.getVersion() }, "missing required metadata");
                }
            }
        }

        // Version number must be valid (valid positive decimal)
        ValidationUtils.invokeValidator(new Validator() {
            @Override
            public void validate(final Object target, final Errors errors) {
                final Item item = (Item) target;
                final BindException err = new BindException(target, "item");
                // only check if it's present, missing validator will catch not present
                if (item != null && item.getVersion() != null && item.getVersion().trim().length() > 0) {
                    try {
                        final Double longVersion = Double.parseDouble(item.getVersion());
                        if (longVersion < 0) {
                            createInvalidVersionError(item, err);
                        }
                    } catch (final NumberFormatException nfe) {
                        createInvalidVersionError(item, err);
                    }
                    errors.addAllErrors(err);
                }
            }

            private void createInvalidVersionError(final Item item, final BindException err) {
                err.addError(new ObjectError("item", new String[] { "item.invalidVersion" }, new String[] { item.getVersion(), item.getIdentifier() }, ""));
            }

            @Override
            public boolean supports(final Class<?> clazz) {
                return Item.class.isAssignableFrom(clazz);
            }
        }, target, errors);

    }

}
